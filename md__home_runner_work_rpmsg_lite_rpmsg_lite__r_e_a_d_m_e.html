<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RPMsg-Lite User&#39;s Guide: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="nxp_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">RPMsg-Lite User&#39;s Guide<span id="projectnumber">&#160;Rev. 5.1.4</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__home_runner_work_rpmsg_lite_rpmsg_lite__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/nxp-mcuxpresso/rpmsg-lite/releases/latest"><img src="https://img.shields.io/github/v/release/nxp-mcuxpresso/rpmsg-lite" alt="Version" class="inline"/></a> <a href="https://github.com/nxp-mcuxpresso/rpmsg-lite/graphs/contributors"><img src="https://img.shields.io/github/contributors/nxp-mcuxpresso/rpmsg-lite" alt="Contributors" class="inline"/></a> <a href="https://github.com/nxp-mcuxpresso/rpmsg-lite/issues"><img src="https://img.shields.io/github/issues/nxp-mcuxpresso/rpmsg-lite" alt="Issues" class="inline"/></a> <a href="https://github.com/nxp-mcuxpresso/rpmsg-lite/pulls"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
RPMSG-Lite</h1>
<p>This documentation describes the RPMsg-Lite component, which is a lightweight implementation of the Remote Processor Messaging (RPMsg) protocol. The RPMsg protocol defines a standardized binary interface used to communicate between multiple cores in a heterogeneous multicore system.</p>
<p>Compared to the RPMsg implementation of the Open Asymmetric Multi Processing (OpenAMP) framework (<a href="https://github.com/OpenAMP/open-amp">https://github.com/OpenAMP/open-amp</a>), the RPMsg-Lite offers a code size reduction, API simplification, and improved modularity. On smaller Cortex-M0+ based systems, it is recommended to use RPMsg-Lite.</p>
<p>The RPMsg-Lite is an open-source component developed by NXP Semiconductors and released under the BSD-compatible license.</p>
<p>For Further documentation, please look at doxygen documentation at: <a href="https://nxp-mcuxpresso.github.io/rpmsg-lite/">https://nxp-mcuxpresso.github.io/rpmsg-lite/</a> </p>
<h2><a class="anchor" id="autotoc_md1"></a>
Motivation to create RPMsg-Lite</h2>
<p>There are multiple reasons why RPMsg-Lite was developed. One reason is the need for the small footprint of the RPMsg protocol-compatible communication component, another reason is the simplification of extensive API of OpenAMP RPMsg implementation.</p>
<p>RPMsg protocol was not documented, and its only definition was given by the Linux Kernel and legacy OpenAMP implementations. This has changed with [1] which is a standardization protocol allowing multiple different implementations to coexist and still be mutually compatible.</p>
<p>Small MCU-based systems often do not implement dynamic memory allocation. The creation of static API in RPMsg-Lite enables another reduction of resource usage. Not only does the dynamic allocation adds another 5 KB of code size, but also communication is slower and less deterministic, which is a property introduced by dynamic memory. The following table shows some rough comparison data between the OpenAMP RPMsg implementation and new RPMsg-Lite implementation:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Component / Configuration   </th><th class="markdownTableHeadNone">Flash [B]   </th><th class="markdownTableHeadNone">RAM [B]    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">OpenAMP RPMsg / Release (reference)   </td><td class="markdownTableBodyNone">5547   </td><td class="markdownTableBodyNone">456 + dynamic    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RPMsg-Lite / Dynamic API, Release   </td><td class="markdownTableBodyNone">3462   </td><td class="markdownTableBodyNone">56 + dynamic    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Relative Difference [%]   </td><td class="markdownTableBodyNone">~62.4%   </td><td class="markdownTableBodyNone">~12.3%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RPMsg-Lite / Static API (no malloc), Release   </td><td class="markdownTableBodyNone">2926   </td><td class="markdownTableBodyNone">352    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Relative Difference [%]   </td><td class="markdownTableBodyNone">~52.7%   </td><td class="markdownTableBodyNone">~77.2%   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md2"></a>
Implementation</h2>
<p>The implementation of RPMsg-Lite can be divided into three sub-components, from which two are optional. The core component is situated in <em>rpmsg_lite.c</em>. Two optional components are used to implement a blocking receive API (in <em>rpmsg_queue.c</em>) and dynamic "named" endpoint creation and deletion announcement service (in <em>rpmsg_ns.c</em>).</p>
<p>The actual "media access" layer is implemented in <em>virtqueue.c</em>, which is one of the few files shared with the OpenAMP implementation. This layer mainly defines the shared memory model, and internally defines used components such as vring or virtqueue.</p>
<p>The porting layer is split into two sub-layers: the environment layer and the platform layer. The first sublayer is to be implemented separately for each environment. (The bare metal environment already exists and is implemented in <em>rpmsg_env_bm.c</em>, and the FreeRTOS environment is implemented in <em>rpmsg_env_freertos.c</em> etc.) Only the source file, which matches the used environment, is included in the target application project. The second sublayer is implemented in <em>rpmsg_platform.c</em> and defines low-level functions for interrupt enabling, disabling, and triggering mainly. The situation is described in the following figure:</p>
<div class="image">
<img src="rpmsg_lite_arch.png" alt=""/>
<div class="caption">
RPMsg-Lite Architecture</div></div>
    <h3><a class="anchor" id="autotoc_md3"></a>
RPMsg-Lite core sub-component</h3>
<p>This subcomponent implements a blocking send API and callback-based receive API. The RPMsg protocol is part of the transport layer. This is realized by using so-called endpoints. Each endpoint can be assigned a different receive callback function. However, it is important to notice that the callback is executed in an interrupt environment in current design. Therefore, certain actions like memory allocation are discouraged to execute in the callback. The following figure shows the role of RPMsg in an ISO/OSI-like layered model:</p>
<div class="image">
<img src="rpmsg_isoosi.png" alt=""/>
<div class="caption">
RPMsg ISO/OSI Layered Model</div></div>
    <h3><a class="anchor" id="autotoc_md4"></a>
Queue sub-component (optional)</h3>
<p>This subcomponent is optional and requires implementation of the env_*_queue() functions in the environment porting layer. It uses a blocking receive API, which is common in RTOS-environments. It supports both copy and nocopy blocking receive functions.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Name Service sub-component (optional)</h3>
<p>This subcomponent is a minimum implementation of the name service which is present in the Linux Kernel implementation of RPMsg. It allows the communicating node both to send announcements about "named" endpoint (in other words, channel) creation or deletion and to receive these announcement taking any user-defined action in an application callback. The endpoint address used to receive name service announcements is arbitrarily fixed to be 53 (0x35).</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Usage</h2>
<p>The application should put the /rpmsg_lite/lib/include directory to the include path and in the application, include either the <a class="el" href="rpmsg__lite_8h_source.html">rpmsg_lite.h</a> header file, or optionally also include the <a class="el" href="rpmsg__queue_8h_source.html">rpmsg_queue.h</a> and/or <a class="el" href="rpmsg__ns_8h_source.html">rpmsg_ns.h</a> files. Both porting sublayers should be provided for you by NXP, but if you plan to use your own RTOS, all you need to do is to implement your own environment layer (in other words, rpmsg_env_myrtos.c) and to include it in the project build.</p>
<p>The initialization of the stack is done by calling the <a class="el" href="group__rpmsg__lite.html#gadd1358b092b054711ed71ea2482c8c8b" title="Initializes the RPMsg-Lite communication stack. Must be called prior to any other RPMSG lite API....">rpmsg_lite_master_init()</a> on the master side and the <a class="el" href="group__rpmsg__lite.html#gaae74478eecba4c3d3fcb9c1e11d25891" title="Initializes the RPMsg-Lite communication stack. Must be called prior to any other RPMsg-Lite API....">rpmsg_lite_remote_init()</a> on the remote side. This initialization function must be called prior to any RPMsg-Lite API call. After the init, it is wise to create a communication endpoint, otherwise communication is not possible. This can be done by calling the <a class="el" href="group__rpmsg__lite.html#gadab572229a911302c0ccc211fcb372e0" title="Create a new rpmsg endpoint, which can be used for communication.">rpmsg_lite_create_ept()</a> function. It optionally accepts a last argument, where an internal context of the endpoint is created, just in case the RL_USE_STATIC_API option is set to 1. If not, the stack internally calls env_alloc() to allocate dynamic memory for it. In case a callback-based receiving is to be used, an ISR-callback is registered to each new endpoint with user-defined callback data pointer. If a blocking receive is desired (in case of RTOS environment), the <a class="el" href="group__rpmsg__queue.html#gaf2b13335342ec06d8c264bbb6e27c88f" title="Create a RPMsg queue which can be used for blocking reception.">rpmsg_queue_create()</a> function must be called before calling <a class="el" href="group__rpmsg__lite.html#gadab572229a911302c0ccc211fcb372e0" title="Create a new rpmsg endpoint, which can be used for communication.">rpmsg_lite_create_ept()</a>. The queue handle is passed to the endpoint creation function as a callback data argument and the callback function is set to <a class="el" href="group__rpmsg__queue.html#gaeb7cba094390762f1131884b2c7e89ce" title="This callback needs to be registered with an endpoint.">rpmsg_queue_rx_cb()</a>. Then, it is possible to use rpmsg_queue_receive() function to listen on a queue object for incoming messages. The <a class="el" href="group__rpmsg__lite.html#ga64dd2dd9b0681e1551c83f325daf19fb" title="Sends a message contained in data field of length size to the remote endpoint with address dst....">rpmsg_lite_send()</a> function is used to send messages to the other side.</p>
<p>The RPMsg-Lite also implements no-copy mechanisms for both sending and receiving operations. These methods require specifics that have to be considered when used in an application.</p>
<p><b>no-copy-send mechanism:</b> This mechanism allows sending messages without the cost for copying data from the application buffer to the RPMsg/virtio buffer in the shared memory. The sequence of no-copy sending steps to be performed is as follows:</p><ul>
<li>Call the <a class="el" href="group__rpmsg__lite.html#ga5ef10752df7885f0ff1fcd34f322173a" title="Allocates the tx buffer for message payload.">rpmsg_lite_alloc_tx_buffer()</a> function to get the virtio buffer and provide the buffer pointer to the application.</li>
<li>Fill the data to be sent into the pre-allocated virtio buffer. Ensure that the filled data does not exceed the buffer size (provided as the <a class="el" href="group__rpmsg__lite.html#ga5ef10752df7885f0ff1fcd34f322173a" title="Allocates the tx buffer for message payload.">rpmsg_lite_alloc_tx_buffer()</a> <em>size</em> output parameter).</li>
<li>Call the <a class="el" href="group__rpmsg__lite.html#ga90bcc1cb74c40a6966492288cd8a3d31" title="Sends a message in tx buffer allocated by rpmsg_lite_alloc_tx_buffer()">rpmsg_lite_send_nocopy()</a> function to send the message to the destination endpoint. Consider the cache functionality and the virtio buffer alignment. See the <a class="el" href="group__rpmsg__lite.html#ga90bcc1cb74c40a6966492288cd8a3d31" title="Sends a message in tx buffer allocated by rpmsg_lite_alloc_tx_buffer()">rpmsg_lite_send_nocopy()</a> function description below.</li>
</ul>
<p><b>no-copy-receive mechanism:</b> This mechanism allows reading messages without the cost for copying data from the virtio buffer in the shared memory to the application buffer. The sequence of no-copy receiving steps to be performed is as follows:</p><ul>
<li>Call the <a class="el" href="group__rpmsg__queue.html#ga70c77536c40ade2d13371846023f6d72" title="blocking receive function - blocking version of the received function that can be called from an RTOS...">rpmsg_queue_recv_nocopy()</a> function to get the virtio buffer pointer to the received data.</li>
<li>Read received data directly from the shared memory.</li>
<li>Call the <a class="el" href="group__rpmsg__queue.html#ga1c3cff098b9464fa89788510bda231a3" title="This function frees a buffer previously returned by rpmsg_queue_recv_nocopy().">rpmsg_queue_nocopy_free()</a> function to release the virtio buffer and to make it available for the next data transfer.</li>
</ul>
<p>The user is responsible for destroying any RPMsg-Lite objects he has created in case of deinitialization. In order to do this, the function <a class="el" href="group__rpmsg__queue.html#ga480a59ddeeef5f54f84cd3977efcd1ec" title="Destroy a queue and clean up. Do not destroy a queue which is registered with an active endpoint!">rpmsg_queue_destroy()</a> is used to destroy a queue, <a class="el" href="group__rpmsg__lite.html#gabd04a23b464f1ba3360d9970b0d09c94" title="This function deletes rpmsg endpoint and performs cleanup.">rpmsg_lite_destroy_ept()</a> is used to destroy an endpoint and finally, <a class="el" href="group__rpmsg__lite.html#ga974c3cb2c613f24a6d951b0aead1852a" title="Deinitialized the RPMsg-Lite communication stack This function always succeeds. rpmsg_lite_init() can...">rpmsg_lite_deinit()</a> is used to deinitialize the RPMsg-Lite intercore communication stack. Deinitialize all endpoints using a queue before deinitializing the queue. Otherwise, you are actively invalidating the used queue handle, which is not allowed. RPMsg-Lite does not check this internally, since its main aim is to be lightweight.</p>
<div class="image">
<img src="rpmsg_lite_send_receive.png" alt=""/>
<div class="caption">
RPMsg Lite copy and no-copy interface, multiple scenarios</div></div>
    <h2><a class="anchor" id="autotoc_md7"></a>
Examples</h2>
<p>RPMsg_Lite multicore examples are part of NXP MCUXpressoSDK packages. Visit <a href="https://mcuxpresso.nxp.com">https://mcuxpresso.nxp.com</a> to configure, build and download these packages. To get the board list with multicore support (RPMsg_Lite included) use filtering based on Middleware and search for 'multicore' string. Once the selected package with the multicore middleware is downloaded, see</p>
<p><code>&lt;MCUXpressoSDK_install_dir&gt;</code>/boards/<code>&lt;board_name&gt;</code>/multicore_examples for RPMsg_Lite multicore examples with 'rpmsg_lite_' name prefix.</p>
<p>Another way of getting NXP MCUXpressoSDK RPMsg_Lite multicore examples is using the <a href="https://github.com/nxp-mcuxpresso/mcuxsdk-manifests">mcuxsdk-manifests</a> Github repo. Follow the description how to use the West tool to clone and update the mcuxsdk-manifests repo in <a href="https://github.com/nxp-mcuxpresso/mcuxsdk-manifests?tab=readme-ov-file#readme">readme section</a>. Once done the armgcc rpmsg_lite examples can be found in</p>
<p>mcuxsdk/examples/_<code>&lt;board_name&gt;</code>/multicore_examples</p>
<p>You can use the evkmimxrt1170 as the board_name for instance. Similar to MCUXpressoSDK packages the RPMsg_Lite examples use the 'rpmsg_lite_' name prefix. </p>
<h2><a class="anchor" id="autotoc_md8"></a>
Notes</h2>
<h3><a class="anchor" id="autotoc_md9"></a>
Environment layers implementation</h3>
<p>Several environment layers are provided in lib/rpmsg_lite/porting/environment folder. Not all of them are fully tested however. Here is the list of environment layers that passed testing:</p><ul>
<li>rpmsg_env_bm.c</li>
<li>rpmsg_env_freertos.c</li>
<li>rpmsg_env_xos.c</li>
<li>rpmsg_env_threadx.c</li>
</ul>
<p>The rest of environment layers has been created and used in some experimental projects, it has been running well at the time of creation but due to the lack of unit testing there is no guarantee it is still fully functional.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Shared memory configuration</h3>
<p>It is important to correctly initialize/configure the shared memory for data exchange in the application. The shared memory must be accessible from both the master and the remote core and it needs to be configured as Non-Cacheable memory. Dedicated shared memory section in liker file is also a good practise, it is recommended to use linker files from MCUXpressSDK packages for NXP devices based applications. It needs to be ensured no other application part/component is unintentionally accessing this part of memory.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Configuration options</h2>
<p>The RPMsg-Lite can be configured at the compile time. The default configuration is defined in the <a class="el" href="rpmsg__default__config_8h.html">rpmsg_default_config.h</a> header file. This configuration can be customized by the user by including rpmsg_config.h file with custom settings. The following table summarizes all possible RPMsg-Lite configuration options.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Configuration option   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Usage    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_MS_PER_INTERVAL   </td><td class="markdownTableBodyNone">(1)   </td><td class="markdownTableBodyNone">Delay in milliseconds used in non-blocking API functions for polling.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RL_BUFFER_PAYLOAD_SIZE   </td><td class="markdownTableBodyNone">(496)   </td><td class="markdownTableBodyNone">Size of the buffer payload, it must be equal to (240, 496, 1008, ...) [2^n - 16]    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_BUFFER_COUNT   </td><td class="markdownTableBodyNone">(2)   </td><td class="markdownTableBodyNone">Number of the buffers, it must be power of two (2, 4, ...)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RL_API_HAS_ZEROCOPY   </td><td class="markdownTableBodyNone">(1)   </td><td class="markdownTableBodyNone">Zero-copy API functions enabled/disabled.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_USE_STATIC_API   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">Static API functions (no dynamic allocation) enabled/disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RL_USE_DCACHE   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">Memory cache management of shared memory. Use in case of data cache is enabled for shared memory.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_CLEAR_USED_BUFFERS   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">Clearing used buffers before returning back to the pool of free buffers enabled/disabled.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RL_USE_MCMGR_IPC_ISR_HANDLER   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">When enabled IPC interrupts are managed by the Multicore Manager (IPC interrupts router), when disabled RPMsg-Lite manages IPC interrupts by itself.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_USE_ENVIRONMENT_CONTEXT   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">When enabled the environment layer uses its own context. Required for some environments (QNX). The default value is 0 (no context, saves some RAM).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RL_DEBUG_CHECK_BUFFERS   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">When enabled buffer pointers passed to <a class="el" href="group__rpmsg__lite.html#ga90bcc1cb74c40a6966492288cd8a3d31" title="Sends a message in tx buffer allocated by rpmsg_lite_alloc_tx_buffer()">rpmsg_lite_send_nocopy()</a> and <a class="el" href="group__rpmsg__lite.html#ga847cb39c655a6068107ac9840cfd7bf2" title="Releases the rx buffer for future reuse in vring. This API can be called at process context when the ...">rpmsg_lite_release_rx_buffer()</a> functions (enabled by RL_API_HAS_ZEROCOPY config) are checked to avoid passing invalid buffer pointer. The default value is 0 (disabled). Do not use in RPMsg-Lite to Linux configuration.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_ALLOW_CONSUMED_BUFFERS_NOTIFICATION   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">When enabled the opposite side is notified each time received buffers are consumed and put into the queue of available buffers. Enable this option in RPMsg-Lite to Linux configuration to allow unblocking of the Linux blocking send. The default value is 0 (RPMsg-Lite to RPMsg-Lite communication).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RL_ALLOW_CUSTOM_SHMEM_CONFIG   </td><td class="markdownTableBodyNone">(0)   </td><td class="markdownTableBodyNone">It allows to define custom shared memory configuration and replacing the shared memory related global settings from rpmsg_config.h This is useful when multiple instances are running in parallel but different shared memory arrangement (vring size &amp; alignment, buffers size &amp; count) is required. The default value is 0 (all RPMsg_Lite instances use the same shared memory arrangement as defined by common config macros).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RL_ASSERT   </td><td class="markdownTableBodyNone">see <a class="el" href="rpmsg__default__config_8h.html">rpmsg_default_config.h</a>   </td><td class="markdownTableBodyNone">Assert implementation.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md12"></a>
Contributing to the rpmsg-lite project</h2>
<p>We welcome and encourage the community to submit patches directly to the rpmsg-lite project placed on github. Contributing can be managed via pull-requests. Before a pull-request is created the code should be tested and properly formatted.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
How to format rpmsg-lite code</h3>
<p>To format code, use the application developed by Google, named <em>clang-format</em>. This tool is part of the <a href="http://llvm.org/">llvm</a> project. Currently, the clang-format 10.0.0 version is used for rpmsg-lite. The set of style settings used for clang-format is defined in the <code>.clang-format</code> file, placed in a root of the rpmsg-lite directory where Python script <code>run_clang_format.py</code> can be executed. This script executes the application named <em>clang-format.exe</em>. You need to have the path of this application in the OS's environment path, or you need to change the script. </p>
<h2><a class="anchor" id="autotoc_md14"></a>
References</h2>
<h2><a class="anchor" id="autotoc_md15"></a>
[1] M. Novak, M. Cingel, Lockless Shared Memory Based Multicore Communication Protocol</h2>
<p>Copyright © 2016 Freescale Semiconductor, Inc. Copyright © 2016-2025 NXP </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">Copyright 2016-2025 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
